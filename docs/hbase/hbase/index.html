<!DOCTYPE html>
<html lang="zh-cn" dir="ltr" class="scroll-smooth" data-default-appearance="light"
  data-auto-appearance="true"><head>
  <meta charset="utf-8" />
  
  <meta http-equiv="content-language" content="zh-cn" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  
  <title> &middot; KV先生</title>
  <meta name="title" content=" &middot; KV先生" />
  
  
  
  
  
  <link rel="canonical" href="https://your_domain.com/docs/hbase/hbase/" />
  
  
  
  
  
  
  
  
  
  
  <link type="text/css" rel="stylesheet" href="/css/main.bundle.min.8ea60310059bae0843ca33ef1de0ed63f1367330a68d9b13d82d6c3bc474a4c1a7c705dba2592e367518d4eb2c0a82076592aeab874ff2e02034ddc7147c752f.css"
    integrity="sha512-jqYDEAWbrghDyjPvHeDtY/E2czCmjZsT2C1sO8R0pMGnxwXbolkuNnUY1OssCoIHZZKuq4dP8uAgNN3HFHx1Lw==" />
  
  
  <script type="text/javascript" src="/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js"
    integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj&#43;e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
  
  
  
  
  
  
  
  
  
  <script defer type="text/javascript" id="script-bundle" src="/js/main.bundle.min.b3e22525a7c62c7b8e4c7c002546ab6498031635fa2d07802d593d476d7ab1262ec61b0cec0fe9f5653e1c9e6c256cbd0b66e5a8421b4f82a7bd2c1d5c901638.js"
    integrity="sha512-s&#43;IlJafGLHuOTHwAJUarZJgDFjX6LQeALVk9R216sSYuxhsM7A/p9WU&#43;HJ5sJWy9C2blqEIbT4KnvSwdXJAWOA==" data-copy="" data-copied=""></script>
  
  
  <script src="/js/zoom.min.js"></script>
  
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="manifest" href="/site.webmanifest" />
  
  
  
  
  
  
  
  <meta property="og:url" content="https://your_domain.com/docs/hbase/hbase/">
  <meta property="og:site_name" content="KV先生">
  <meta property="og:title" content="KV先生">
  <meta property="og:description" content="HBase # 基本概念 # 列族是什么，扩展是什么，关系型数据库，">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="KV先生">
  <meta name="twitter:description" content="HBase # 基本概念 # 列族是什么，扩展是什么，关系型数据库，">

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Docs",
    "name": "",
    "headline": "",
    
    "abstract": "HBase # 基本概念 # 列族是什么，扩展是什么，关系型数据库，",
    "inLanguage": "zh-cn",
    "url" : "https:\/\/your_domain.com\/docs\/hbase\/hbase\/",
    "author" : {
      "@type": "Person",
      "name": "KV先生"
    },
    
    
    
    
    
    
    
    
    "mainEntityOfPage": "true",
    "wordCount": "2728"
  }]
  </script>


  
  
  <meta name="author" content="KV先生" />
  
  
  
  <link href="mailto:hello@your_domain.com" rel="me" />
  
  
  <link href="https://github.com/bot-ruoshui" rel="me" />
  
  
  
  

<script src="/lib/jquery/jquery.slim.min.js" integrity=""></script>





















  
  


  
  
  <meta name="theme-color"/>
  
  
</head>
<body
  class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32 scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600">
  <div id="the-top" class="absolute flex self-center">
    <a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
      href="#main-content"><span
        class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>跳过正文</a>
  </div>
  
  
  <div class="min-h-[148px]"></div>
<div class="fixed inset-x-0 pl-[24px] pr-[24px]" style="z-index:100">
  <div id="menu-blur" class="absolute opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl shadow-2xl"></div>
  <div class="relative max-w-[64rem] ml-auto mr-auto">
    <div style="padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px"
    class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3">
    
    <div class="flex flex-1 items-center justify-between">
        <nav class="flex space-x-3">

            
            <a href="/" class="text-base font-medium text-gray-500 hover:text-gray-900">
	            <span style="font-weight:600;font-size:18px;">KV先生</span>
	        </a>
            

        </nav>
        <nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12">

            
            
            
  <a href="/docs/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        文档
    </p>
</a>



            
            
  <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <p class="text-base font-medium" title="">
        标签
    </p>
</a>



            
            
  <a href="https://github.com/5mrhelloworld"  target="_blank"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
    
    <span >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>


    </span>
    
    <p class="text-base font-medium" title="">
        
    </p>
</a>



            
            

            


            
            <button id="search-button" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            


            
            
            <div
                class="ltr:mr-14 rtl:ml-14 flex items-center">
                <button id="appearance-switcher" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400">
                    <div class="flex items-center justify-center dark:hidden">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                    </div>
                    <div class="items-center justify-center hidden dark:flex">
                        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                    </div>
                </button>
            </div>
            

        </nav>
        <div class="flex md:hidden items-center space-x-5 md:ml-12 h-12">

            <span></span>

            


            
            <button id="search-button-mobile" aria-label="Search" class="text-base hover:text-primary-600 dark:hover:text-primary-400"
                title="">
                

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


            </button>
            

            
            
            <button id="appearance-switcher-mobile" aria-label="Dark mode switcher" type="button" class="text-base hover:text-primary-600 dark:hover:text-primary-400" style="margin-right:5px">
                <div class="flex items-center justify-center dark:hidden">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>

  </span>


                </div>
                <div class="items-center justify-center hidden dark:flex">
                    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>

  </span>


                </div>
            </button>
            

        </div>
    </div>
    <div class="-my-2 -mr-2 md:hidden">

        <label id="menu-button" for="menu-controller" class="block">
            <input type="checkbox" id="menu-controller" class="hidden" />
            
            <div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400">
                

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>

  </span>


            </div>
            <div id="menu-wrapper" style="padding-top:5px;"
                class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50">
                <ul
                    class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl">

                    <li>
                        <span
                            class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>

</span>
                    </li>

                    

                    
  <li class="mt-1">
    <a href="/docs/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            文档
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="/tags/"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <p class="text-bg font-bg" title="">
            标签
        </p>
    </a>
</li>




                    

                    
  <li class="mt-1">
    <a href="https://github.com/5mrhelloworld"  target="_blank"  class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400">
        
        <div >
            

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>


        </div>
        
        <p class="text-bg font-bg" title="">
            
        </p>
    </a>
</li>




                    

                </ul>
                
                

            </div>
        </label>
    </div>
</div>





  </div>
</div>
<script>
  window.addEventListener('scroll', function (e) {
    var scroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    var background_blur = document.getElementById('menu-blur');
    background_blur.style.opacity = (scroll / 300);
  });
</script>

  
  <div class="relative flex flex-col grow">
    <main id="main-content" class="grow">
      


<article>
  

  <header id="single_header" class="mt-5 max-w-prose">
    
    <ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden">
  
  
    
  
    
  
  
  <li class="inline hidden">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/"
      >文章</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  
  <li class="inline ">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/docs/"
      >文章</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

  
  
  <li class="inline hidden">
    <a
      class="hover:underline decoration-neutral-300 dark:underline-neutral-600"
      href="/docs/hbase/hbase/"
      >文章</a
    ><span class="px-1 text-primary-500">/</span>
  </li>

</ol>


    
    <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
      
    </h1>
    <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
      





  
  







  





  



  













<div class="flex flex-row flex-wrap items-center">
  
  
  <time datetime="0001-01-01 00:00:00 &#43;0000 UTC">0001-01-01</time><span class="px-2 text-primary-500">&middot;</span><span>2728 字</span><span class="px-2 text-primary-500">&middot;</span><span title="预计阅读">13 分钟</span>
  

  
  
</div>





<div class="flex flex-row flex-wrap items-center">
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>



    </div>

    
    
    
    
    

    

    
      
      
        
        
<div class="flex author">
  
    
    
      
    
    
      
        
      
      <img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width="96" height="96"
      alt="KV先生" src="/img/wmz_hu0f64dbd4a3f6623dcafe1cf79b5f4bcf_435948_192x192_fill_q75_box_center.jpg" />
    
  
  <div class="place-self-center">
    
    <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
      作者
    </div>
    <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
      KV先生
    </div>
    
    
    <div class="text-sm text-neutral-700 dark:text-neutral-400">rosser</div>
    
    <div class="text-2xl sm:text-lg">
  <div class="flex flex-wrap text-neutral-400 dark:text-neutral-500">
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="mailto:hello@your_domain.com"
          target="_blank"
          aria-label="Email"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1c-27.64 140.9 68.65 266.2 199.1 285.1c19.01 2.888 36.17-12.26 36.17-31.49l.0001-.6631c0-15.74-11.44-28.88-26.84-31.24c-84.35-12.98-149.2-86.13-149.2-174.2c0-102.9 88.61-185.5 193.4-175.4c91.54 8.869 158.6 91.25 158.6 183.2l0 16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98 .0036c-7.299 0-13.2 4.992-15.12 11.68c-24.85-12.15-54.24-16.38-86.06-5.106c-38.75 13.73-68.12 48.91-73.72 89.64c-9.483 69.01 43.81 128 110.9 128c26.44 0 50.43-9.544 69.59-24.88c24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3C495.1 107.1 361.2-9.332 207.8 20.73zM239.1 304.3c-26.47 0-48-21.56-48-48.05s21.53-48.05 48-48.05s48 21.56 48 48.05S266.5 304.3 239.1 304.3z"/></svg>

  </span>

</span></a
        >
      
    
      
        <a
          class="px-1 hover:text-primary-700 dark:hover:text-primary-400"
          href="https://github.com/bot-ruoshui"
          target="_blank"
          aria-label="Github"
          rel="me noopener noreferrer"
          ><span class="inline-block align-text-bottom">

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

  </span>

</span></a
        >
      
    
  </div>

</div>
  </div>
</div>

      

      

      
      <div class="mb-5"></div>
      

    

  </header>
  
  <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
    
     <div
      class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8">
      <div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-[140px]">

         <details open id="TOCView"
  class="toc-right mt-0 overflow-y-scroll overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block">
  <summary
    class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="min-w-[220px] py-2 border-dotted ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基本概念">基本概念</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#特点">特点</a>
          <ul>
            <li><a href="#易扩展">易扩展</a></li>
            <li><a href="#内容大">内容大</a></li>
            <li><a href="#面向列">面向列</a></li>
            <li><a href="#多版本">多版本</a></li>
            <li><a href="#稀疏性">稀疏性</a></li>
            <li><a href="#高可靠">高可靠</a></li>
            <li><a href="#高性能">高性能</a></li>
          </ul>
        </li>
        <li><a href="#应用">应用</a></li>
      </ul>
    </li>
    <li><a href="#数据模型">数据模型</a>
      <ul>
        <li><a href="#namespace">NameSpace</a></li>
        <li><a href="#table">Table</a></li>
        <li><a href="#rowkey">RowKey</a></li>
        <li><a href="#column-family">Column Family</a></li>
        <li><a href="#column-qualifier">Column Qualifier</a></li>
        <li><a href="#timestamp">Timestamp</a></li>
        <li><a href="#cell">Cell</a></li>
      </ul>
    </li>
    <li><a href="#架构模型">架构模型</a>
      <ul>
        <li><a href="#zookeeper">Zookeeper</a></li>
        <li><a href="#client">Client</a></li>
        <li><a href="#hmaster">HMaster</a></li>
        <li><a href="#hregionserver">HRegionServer</a></li>
        <li><a href="#hregion">HRegion</a>
          <ul>
            <li><a href="#split">Split</a></li>
          </ul>
        </li>
        <li><a href="#store">Store</a></li>
        <li><a href="#hfile">HFile</a>
          <ul>
            <li><a href="#基本概念-1">基本概念</a></li>
            <li><a href="#文件结构">文件结构</a></li>
            <li><a href="#why-fast">Why Fast</a></li>
          </ul>
        </li>
        <li><a href="#hlog">HLog</a></li>
        <li><a href="#hdfs">HDFS</a></li>
      </ul>
    </li>
    <li><a href="#blockcache">BlockCache</a>
      <ul>
        <li><a href="#lrublockcache">LRUBlockCache</a></li>
        <li><a href="#bucketcache">BucketCache</a>
          <ul>
            <li><a href="#基本介绍">基本介绍</a></li>
            <li><a href="#相关配置">相关配置</a></li>
          </ul>
        </li>
        <li><a href="#combined-blockcahce组合模式">Combined BlockCahce（组合模式）</a>
          <ul>
            <li><a href="#bucketcache-中-block-的缓存写入读取流程">BucketCache 中 Block 的缓存写入/读取流程</a></li>
          </ul>
        </li>
        <li><a href="#压缩-blockcache">压缩 BlockCache</a></li>
      </ul>
    </li>
    <li><a href="#交互方式">交互方式</a></li>
    <li><a href="#读写流程">读写流程</a>
      <ul>
        <li><a href="#三层索引">三层索引</a></li>
        <li><a href="#读取数据流程">读取数据流程</a>
          <ul>
            <li><a href="#数据组织">数据组织</a></li>
            <li><a href="#查询过程">查询过程</a></li>
          </ul>
        </li>
        <li><a href="#写入数据流程">写入数据流程</a></li>
      </ul>
    </li>
    <li><a href="#数据刷写">数据刷写</a>
      <ul>
        <li><a href="#触发时机">触发时机</a></li>
        <li><a href="#刷写策略">刷写策略</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</details>
<details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden">
  <summary
    class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">
    目录
  </summary>
  <div
    class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基本概念">基本概念</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#特点">特点</a>
          <ul>
            <li><a href="#易扩展">易扩展</a></li>
            <li><a href="#内容大">内容大</a></li>
            <li><a href="#面向列">面向列</a></li>
            <li><a href="#多版本">多版本</a></li>
            <li><a href="#稀疏性">稀疏性</a></li>
            <li><a href="#高可靠">高可靠</a></li>
            <li><a href="#高性能">高性能</a></li>
          </ul>
        </li>
        <li><a href="#应用">应用</a></li>
      </ul>
    </li>
    <li><a href="#数据模型">数据模型</a>
      <ul>
        <li><a href="#namespace">NameSpace</a></li>
        <li><a href="#table">Table</a></li>
        <li><a href="#rowkey">RowKey</a></li>
        <li><a href="#column-family">Column Family</a></li>
        <li><a href="#column-qualifier">Column Qualifier</a></li>
        <li><a href="#timestamp">Timestamp</a></li>
        <li><a href="#cell">Cell</a></li>
      </ul>
    </li>
    <li><a href="#架构模型">架构模型</a>
      <ul>
        <li><a href="#zookeeper">Zookeeper</a></li>
        <li><a href="#client">Client</a></li>
        <li><a href="#hmaster">HMaster</a></li>
        <li><a href="#hregionserver">HRegionServer</a></li>
        <li><a href="#hregion">HRegion</a>
          <ul>
            <li><a href="#split">Split</a></li>
          </ul>
        </li>
        <li><a href="#store">Store</a></li>
        <li><a href="#hfile">HFile</a>
          <ul>
            <li><a href="#基本概念-1">基本概念</a></li>
            <li><a href="#文件结构">文件结构</a></li>
            <li><a href="#why-fast">Why Fast</a></li>
          </ul>
        </li>
        <li><a href="#hlog">HLog</a></li>
        <li><a href="#hdfs">HDFS</a></li>
      </ul>
    </li>
    <li><a href="#blockcache">BlockCache</a>
      <ul>
        <li><a href="#lrublockcache">LRUBlockCache</a></li>
        <li><a href="#bucketcache">BucketCache</a>
          <ul>
            <li><a href="#基本介绍">基本介绍</a></li>
            <li><a href="#相关配置">相关配置</a></li>
          </ul>
        </li>
        <li><a href="#combined-blockcahce组合模式">Combined BlockCahce（组合模式）</a>
          <ul>
            <li><a href="#bucketcache-中-block-的缓存写入读取流程">BucketCache 中 Block 的缓存写入/读取流程</a></li>
          </ul>
        </li>
        <li><a href="#压缩-blockcache">压缩 BlockCache</a></li>
      </ul>
    </li>
    <li><a href="#交互方式">交互方式</a></li>
    <li><a href="#读写流程">读写流程</a>
      <ul>
        <li><a href="#三层索引">三层索引</a></li>
        <li><a href="#读取数据流程">读取数据流程</a>
          <ul>
            <li><a href="#数据组织">数据组织</a></li>
            <li><a href="#查询过程">查询过程</a></li>
          </ul>
        </li>
        <li><a href="#写入数据流程">写入数据流程</a></li>
      </ul>
    </li>
    <li><a href="#数据刷写">数据刷写</a>
      <ul>
        <li><a href="#触发时机">触发时机</a></li>
        <li><a href="#刷写策略">刷写策略</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</details>

<script>

  var margin = 200;
  var marginError = 50;

  (function () {
    var $window = $(window);
    var $toc = $('#TOCView');
    var tocHeight = $toc.height();

    function onResize() {
      var windowAndMarginHeight = $window.height() - margin;
      if(tocHeight >= windowAndMarginHeight) {
        $toc.css("overflow-y", "scroll")
        $toc.css("max-height", (windowAndMarginHeight + marginError) + "px")
      } else {
        $toc.css("overflow-y", "hidden")
        $toc.css("max-height", "9999999px")
      }
    }

    $window.on('resize', onResize);
    $(document).ready(onResize);
  })();



</script>
   </div>
      </div>
      

      <div class="min-w-0 min-h-0 max-w-fit">
        
        


        <div class="article-content max-w-prose mb-20">
          

<h1 class="relative group">HBase 
    <div id="hbase" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hbase" aria-label="锚点">#</a>
    </span>        
    
</h1>


<h2 class="relative group">基本概念 
    <div id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>列族是什么，扩展是什么，关系型数据库，</p>


<h3 class="relative group">简介 
    <div id="%E7%AE%80%E4%BB%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%AE%80%E4%BB%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>　　Apache HBase（Hadoop DataBase）是一个开源的、高可靠性、高性能、面向列（这里指列族，非列式存储）、可伸缩、实时读写的分布式数据库，其设计思想来源于 Google 的 BigTable 论文。利用 Hadoop HDFS 作为其文件存储系统，利用 ZooKeeper 作为其分布式协同服务。主要用来存储非结构化和半结构化的松散数据（列式存储 NoSQL 数据库）。
　　
　　HBase良好的分布式架构设计为海量数据的快速存储、随机访问提供了可能，基于数据副本机制和分区机制可以轻松实现在线扩容、缩容和数据容灾，是大数据领域中K-V数据结构存储最常用的数据方案
　　注意：HBase是列组数据库（Column-Family Database），不是列式数据库（Column-Oriented Database）
　　总结：HBase是运行在HDFS之上的面向列族的数据库管理系统。
</code></pre>

<h3 class="relative group">特点 
    <div id="%E7%89%B9%E7%82%B9" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%89%B9%E7%82%B9" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">易扩展 
    <div id="%E6%98%93%E6%89%A9%E5%B1%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%98%93%E6%89%A9%E5%B1%95" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>　HBase 的扩展性主要体现在两个方面，一个是基于运算能力（HRegionServer） 的扩展，通过增加 HRegionSever 节点的数量，提升 HBase 上层的处理能力；另一个是基于存储能力的扩展（HDFS），通过增加 DataNode 节点数量对存储层的进行扩容，提升 HBase 的数据存储能力。
</code></pre>

<h4 class="relative group">内容大 
    <div id="%E5%86%85%E5%AE%B9%E5%A4%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%86%85%E5%AE%B9%E5%A4%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	HBase 单表可以有十亿行、百万列，数据矩阵横向和纵向两个维度所支持的数据量级都非常具有弹性。HBase 的主要作用就是面向 PB 级别数据的实时入库和快速随机访问。这主要源于上述易扩展的特点，使得 HBase 通过扩展来存储海量的数据
</code></pre>

<h4 class="relative group">面向列 
    <div id="%E9%9D%A2%E5%90%91%E5%88%97" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%9D%A2%E5%90%91%E5%88%97" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	HBase 是根据列族来存储数据的，列族下面可以有非常多的列。列式存储的最大好处就是，其数据在表中是按照某列存储的，这样在查询只需要少数几个字段时，能大大减少读取的数据量。还可以动态增加列，可单独对列进行各方面的操
作。
</code></pre>

<h4 class="relative group">多版本 
    <div id="%E5%A4%9A%E7%89%88%E6%9C%AC" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%A4%9A%E7%89%88%E6%9C%AC" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>HBase 的每个列的数据存储支持多个 Version，比如住址列，可能有多个变更。
</code></pre>

<h4 class="relative group">稀疏性 
    <div id="%E7%A8%80%E7%96%8F%E6%80%A7" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%A8%80%E7%96%8F%E6%80%A7" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	为空的列并不占用存储空间，表可以设计的非常稀疏。不必像关系型数据库那样需要预先知道所有列名然后再进行
null 填充。
</code></pre>

<h4 class="relative group">高可靠 
    <div id="%E9%AB%98%E5%8F%AF%E9%9D%A0" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%AB%98%E5%8F%AF%E9%9D%A0" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	WAL（Write Ahead Log）日志先行机制，保证数据写入的时候不会因为集群异常而导致写入数据丢失。Replication 机制，保证了集群在出现严重问题的时候，数据不会发生丢失或者损坏。HBase 底层使用 HDFS，本身也有备份。
</code></pre>

<h4 class="relative group">高性能 
    <div id="%E9%AB%98%E6%80%A7%E8%83%BD" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E9%AB%98%E6%80%A7%E8%83%BD" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	HBase 底层采用 LSM 树（Log-Structured Merge-Tree）数据结构进行存储，底层的 LSM 树数据结构和 RowKey 有序排列等架构上的独特设计，使得 HBase 写入性能非常高。HRegion 切分、主键索引、缓存机制使得 HBase 在海量数据下具备一定的随机读取性能，该性能针对 RowKey 的查询能够到达毫秒级别。LSM 树属于树形结构，最末端的子节点是以内存的方式进行存储的，内存中的小树会 Flush 到磁盘中（当子节点达到一定阈值以后，会放到磁盘中，且存入的过程会进行实时 Merge 成一个主节点，然后磁盘中的树定期会做 Merge 操作，合并成一棵大树，以优化读性能）。
</code></pre>

<h3 class="relative group">应用 
    <div id="%E5%BA%94%E7%94%A8" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%BA%94%E7%94%A8" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	HBase 是一种 NoSQL 数据库，这意味着它不像传统的 RDBMS 数据库那样支持 SQL 作为查询语言。HBase 是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库，它缺少很多 RDBMS 系统的特性，比如列类型，辅助索引，触发器和高级查询语言等。
	HBase 不适合解决所有的问题，首先数据量要足够大，如果有十亿或百亿行数据，那么 HBase 是一个很好的选择，如果只有几百万行甚至不到的数据量，RDBMS 是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态。其次，如果你不需要辅助索引，静态类型的列，事务等特性可以考虑 HBase。但是一个已经用 RDBMS的系统想要切换到 HBase，则需要重新设计系统。最后，保证硬件资源足够，每个 HDFS 集群在少于 5 个节点的时候，都不能表现的很好。因为 HDFS 默认的复制数量是 3，再加上一个 NameNode。其实 HBase 在单机环境下也能运行，但是请在开发环境中进行使用。
	
	适合 HBase 的应用：
存储业务数据：车辆 GPS 信息，司机点位信息，用户操作信息，设备访问信息。
存储日志数据：架构监控数据（登录日志，中间件访问日志，推送日志，短信邮件发送记录），业务操作日志信息。
存储业务附件：UDFS 系统（去中心化文件系统）存储图像，视频，文档等附件信息。
</code></pre><table>
<thead>
<tr>
<th>属性</th>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>只有字符串</td>
<td>丰富的数据类型</td>
</tr>
<tr>
<td>数据操作</td>
<td>增删改查，不支持JOIN</td>
<td>各种各样的函数和表连接</td>
</tr>
<tr>
<td>存储模式</td>
<td>列式存储</td>
<td>表结构和行式存储</td>
</tr>
<tr>
<td>数据保护</td>
<td>更新后仍然保留旧版本</td>
<td>替换</td>
</tr>
<tr>
<td>可伸缩性</td>
<td>轻易增加节点</td>
<td>需要中间层牺牲性能</td>
</tr>
</tbody>
</table>


<h2 class="relative group">数据模型 
    <div id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>​	在HBase表中，一条数据拥有一个全局唯一的主键（RowKey）和任意数量的列（Column Qualifier），每个列的数据存储支持多个版本（Version），一列或多列组成一个列族（Column Family），同一个列族或列的数据在物理上存储在同一个HFile中。这样基于列存储的数据结构有利于数据缓存和查询。</p>
<p>​	HBase中定位一条数据需要通过：RowKey -&gt; Column Family -&gt; Column Qualifier -&gt; Version</p>
<p>　　HBase 表中的数据是疏松地存储的，因此用户可以动态地为数据定义各种不同的列。HBase 中的数据按主键排序（字典序），同时 HBase 会将表按主键划分为多个 HRegion 存储在不同的 HRegionServer 上，以完成数据的分布式存储和读取</p>


<h3 class="relative group">NameSpace 
    <div id="namespace" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#namespace" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	命名空间类似于关系型数据库中的数据库的概念，他其实是表的逻辑分组。这种抽象为多租户相关功能奠定了基础。命名空间是可以管理维护的，可以创建，删除或更改命名空间。HBase 有两个特殊预定义的命名空间：
	default：没有明确指定命名空间的表将自动落入此命名空间
	hbase：系统命名空间，用于包含 HBase 的内部表和元数据表
</code></pre>

<h3 class="relative group">Table 
    <div id="table" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#table" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>​	Table 和关系型数据库中的表一个意思，由行和列组成。</p>


<h3 class="relative group">RowKey 
    <div id="rowkey" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#rowkey" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	RowKey的概念和关系型数据库中的主键相似，是一行数据的唯一标识。RowKey 可以是任意字符串（最大长度是
64KB，实际应用中长度一般为 10-100 Bytes），RowKey 以字节数组保存。存储数据时，数据会按照 RowKey 的字典序排序存储，所以设计 RowKey 时，要充分利用排序存储这个特性，将经常一起读取的行存放到一起。
　　访问 HBase 数据的方式有三种：
		基于 RowKey 的单行查询；
		基于 RowKey 的范围查询；
		全表扫描查询。
</code></pre>

<h3 class="relative group">Column Family 
    <div id="column-family" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#column-family" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	Column Family 即列族，HBase 基于列划分数据的物理存储，同一个列族中列的数据在物理上都存储在同一个 HFile中。一个列族可以包含任意多列，一般同一类的列会放在一个列族中，每个列族都有一组存储属性：
		是否应该缓存在内存中；
		数据如何被压缩或行键如何编码等。
　　HBase 在创建表的时候就必须指定列族。HBase 的列族不是越多越好，官方推荐一个表的列族数量最好小于或者等于三，过多的列族不利于 HBase 数据的管理和索引
</code></pre>

<h3 class="relative group">Column Qualifier 
    <div id="column-qualifier" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#column-qualifier" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	列族的限定词，理解为列的唯一标识。但是列标识是可以改变的，因此每一行可能有不同的列标识。使用的时候必
须 列族:列 ，列可以根据需求动态添加或者删除，同一个表中不同行的数据列都可以不同。
</code></pre>

<h3 class="relative group">Timestamp 
    <div id="timestamp" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#timestamp" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	Timestamp 是实现 HBase 多版本的关键。在 HBase 中，使用不同的 Timestamp 来标识相同 RowKey 对应的不同版本的数据。相同 RowKey 的数据按照 Timestamp 倒序排列，默认查询的是最新的版本，当然用户也可以指定 Timestamp 的值来读取指定版本的数据。
	HBase 通过 RowKey 和 Column Family，Column Qualifier 来确定一个存贮单元，然后再通过时间戳来进行索引。时间戳的类型是 64 位整型，时间戳默认是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。
	为了避免数据存在过多版本而造成管理（包括存贮和索引）负担，HBase 提供了两种数据版本回收方案：
		一是保存数据的最后 n 个版本
		二是保存最近一段时间内的版本（比如最近七天）
</code></pre>

<h3 class="relative group">Cell 
    <div id="cell" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#cell" aria-label="锚点">#</a>
    </span>        
    
</h3>
<p>　　Cell 由 Row，Column Family，Column Qualifier，Version 组成。Cell 中的数据是没有类型的，全部使用字节码形式存贮，因为 HDFS 上的数据都是字节数组。</p>


<h2 class="relative group">架构模型 
    <div id="%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B" aria-label="锚点">#</a>
    </span>        
    
</h2>
<p>　　HBase 可以将数据存储在本地文件系统，也可以存储在 HDFS 文件系统。在生产环境中，HBase 一般运行在 HDFS上，以 HDFS 作为基础的存储设施。用户通过 HBase Client 提供的 Shell 或 Java API 来访问 HBase 数据库，以完成数据的写入和读取。HBase 集群主要由 HMaster、HRegionServer 和 ZooKeeper 组成</p>


<h3 class="relative group">Zookeeper 
    <div id="zookeeper" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#zookeeper" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	HBase 通过 ZooKeeper 来完成选举 HMaster、监控 HRegionServer、维护元数据集群配置等工作。
	
选举HMaster：保证任何时候，都只有一个HMaster，实现HM主从节点的Failover
监控HRegionServer（节点探活）：实时监控HRegionServer的状态，将HRegionServer的上下线信息实时报告给HM
维护员数据和集群配置：存放整个HBase集群的元数据以及集群的状态信息包括：
	存储所有HRegiion的寻址入口（hbase:meta 元数据表），存储所有的元数据信息
	存储HBase的Schema，包括有哪些Table，每个Table有哪些Column Family.
</code></pre>

<h3 class="relative group">Client 
    <div id="client" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#client" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>　　HBase Client 为用户提供了访问 HBase 的接口，可以通过元数据表（客户端负责发送请求到数据库）来定位到目标数据的 HRegionServer。客户端连接的方式有很多种：
		HBase Shell
		Java API
		
　　发送的请求主要包括：
		DDL：数据库定义语言（表的建立，删除，添加删除列族，控制版本）
		DML：数据库操作语言（增删改）
		DQL：数据库查询语言（查询，全表扫描，基于主键，基于过滤器）
　　Client 维护着一些 Cache 来加快对 HBase 的访问，比如 HRegione 的位置信息。
</code></pre>

<h3 class="relative group">HMaster 
    <div id="hmaster" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hmaster" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	HMaster是HBase集群的主节点，负责整个集群的管理工作，HMaster可以实现高可用（Active和Backup），通过Zookeeper来维护主备节点的切换。HM主要工作如下
	1、管理分配：管理和分配HRegion，负责启动的时候分配HR到具体的HRegionServer，又或者在分割HRegion时管理HRegion的分配，管理用户对Table结构的DDL操作。
	2、负载均衡：一方面负责将用户的数据均衡的分布在各个HRegionServer上，防止HRegionServer数据倾斜过载。另一方面负责将用户的请求均衡分布在各个HRegionServer上，防止HRS请求过热。
	3、数据维护：发现是失效的HR，并将失效的HR分配到正常的HRS上，当某个HRS下线时，迁移其内部的HR到其他HRS上
	4、权限控制。
</code></pre>

<h3 class="relative group">HRegionServer 
    <div id="hregionserver" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hregionserver" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	HRegionServer直接对接用户的读写请求，是真正干活的节点，属于HBase具体数据的管理者。
1、实时和HMaster保持心跳，汇报当前节点信息
2、当接受到HMaster的命令创建表时，会分配一个HRegion对应一张表
3、负责切分在运行过程中变大的HR
4、当HRS意外关闭的时候，当前节点HR会被其他HRS管理
5、维护HM分配给他的HR，处理这些HR的IO请求
	当客户端发送DML和DQL操作时，HR负责和客户端建立连接
	WAL：Write Ahead Log日志先行，记录了数据写入，更新日志，被用来做故障恢复
	MemStore：写缓存，数据首先会被写入到MemStore中，每个HRegion的每个Column Family都会有一个MemStore
	负责和底层的HDFS交互，存储数据（Hlog，HFile)到HDFS
	BlockCache：读缓存，在内存中存储了最常访问的数据，采用LRU机制进行淘汰
	
	当某个 HRegionServer 宕机后，ZooKeeper 会通知 HMaster 进行失效备援。下线的 HRegionServer 所负责的 HRegion 暂时停止对外提供服务，HMaster 会将该 HRegionServer 所负责的 HRegion 转移到其他 HRegionServer 上，并且会对下线的HRegionServer 进行日志重放，将 MemStore 中还未持久化到磁盘中的数据进行恢复。
	当某台 HRegionServer Failover 的时候，整个过程中 HRegion 中的数据是不可用的，因为它是缺失的。因此，HBase 属于 CP 架构，降低了可用性，具备强一致性读/写。设想一下，如果 Redo 过程中的 HRegion 能够响应请求，那么可用性提高了，则必然返回不一致的数据（因为 Redo 可能还没完成），那么 HBase 的一致性就降低了。
</code></pre>

<h3 class="relative group">HRegion 
    <div id="hregion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hregion" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	一个HRegionServer包含多个HRegion。HBase将表中的数据基于RowKey的不同范围划分到不同的HRegion上，每个HRegion都负责一定范围的数据存储和访问
	HRegion时HBase中分布式存储和负载的最小单元，不同的HRegoin可以分布在不同的HRegionServer上。每个表一开始只有一个HRgion，随着数据不断插入表，HRegion会被转移到其他的HRegionServer上，实现负载均衡。
	当Table中的行不断增多，就会有越来越多的HRegion。为了防止前期数据的处理都集中在一个HRS，我们可以根据自己的业务进行预分区。
	这样数据被划分到不同的HR上，每个HR都可以独立的进行镀锡，HB读写数据的时候还可以与多HR分布式并发操作，所以访问速度不会有太大的降低。
</code></pre>

<h4 class="relative group">Split 
    <div id="split" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#split" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	HBase中的Split通过把数据分配到一定数量的HR来达到均衡负载，一个Table会被分配到一个或多个HR中，这些HR会被分配到一个或多个HRS中。在自动Split策略中，当一个HR达到一定大小就会自动Split成两个HR。Table在HR中是按照RowKey来排序的，并且一个RowKey所对应的行只会存储在一个HR中，这一点保证了HBase的强一致性。
	Table初始化的时候如果不配置的话，HB是不知道如何去Split HR的，因为HB不知道应该把哪个Row Key作为Split的开始点，如果我们可以大概预测到RowKey的分布，我们可以使用pre-spliting来帮助我们提起那Split HR。
预测不准确会导致某个HR被集中访问过热。此时auto-spilit会默认按照10G切分。最好是先pre再auto
	HB在灭磁数据合并之后都会针对HR生成一个requestSplit请求，去执行checkSplit，检测FileSize是否达到阈值，超过的会被切分。
	HB自带两种pre-split算法，分别是HexStringSpllit和UniformSplit，如果我们的RowKey是16进制的字符串作为前缀，就适合用HSS。也可以用自己的Split算法。
	
	
	当一个HR达到一定大小，他会自动Split成两个HR。HB0.94版本后有三种默认的Split策略：ConstantSizeRegionSplitPolicy，IncreasingToUpperBoundRegionSplitPolicy 和
KeyPrefixRegionSplitPolicy。

	在0.94版本之前 ConstantSizeRegionSplitPolicy 是默认和唯一的 Split 策略。当某个 Store（对应一个 Column Family）的大小大于配置值 hbase.hregion.max.filesize 的时候（默认 10G）HRegion 就会自动分裂。
	
	在0.94版本之后IncreasingToUpperBoundRegionSplitPolicy石墨认得到Split策略。这个策略中，最小的分裂大小和Table的某个HR个数有关，当StoreFile的值大于时会Split：
	# R 为同一个 Table 中在同一个 HRegionServer 中的 HRegion 的个数
	Min(R^2 * &#34;hbase.hregion.memstore.flush.size&#34;, &#34;hbase.hregion.max.filesize&#34;)
	
	KeyPrefixRegionSplitPolicy可以保证相同前缀的RowKey保存在同一个HR中。指定RowKey前缀位数划分HR，通过读取KeyPrefixRegionSplitPolicy。prefix_length属性，数字类型前缀长度。Split时按照长度对SplitPoint进行截取。适合固定前缀的RowKey。Table中没有设置该属性时，指定此策略效果等同使用ITUBRSP
	我们可以通过配置 hbase.regionserver.region.split.policy 来指定 Split 策略，也可以写我们自己的 Split 策略。
</code></pre>

<h3 class="relative group">Store 
    <div id="store" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#store" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	一个HR由多个Store组成，每个Store都对应一个Column Family，Store包含1个MenStore和若干个StoreFile组成。
	MemStore：作为HB的内存数据存储，数据的写操作会先到MemStore中，当MenStore中的数据增长到制定阈值（默认128M），HRS会启动FlushCache进程将MemStore中的数据写入StoreFile持久化存储，每次写入后都形成一个单独的StoreFile。当客户端检索时，现在MemStore中查找，如果MemStore中不存在，则会在StoreFile中继续查找。
	StoreFile：MemStore中的数据写道文件后就是StoreFile，StoreFile底层是以HFile格式保存。HB以StoreFile的大小判断是否需要切分HR当一个HR中所有StoreFile的大小和数量都增长到超过阈值，HMaster会把当前HR分割为两个，切分后其中一个HR会被转移大其他的HRS上，实现均衡负载。
	HFile：HFile和StoreFile是同一个文件，只不过站在HDFS的角度称这个文件为HFile，站在HB角度称这个文件为StoreFile，是HB在HDFS中存储数据的格式，包含多层的索引，在这样的HB检索的时候就不用完全加载整个文件。
</code></pre>

<h3 class="relative group">HFile 
    <div id="hfile" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hfile" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">基本概念 
    <div id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1" aria-label="锚点">#</a>
    </span>        
    
</h4>
<p>官方文档：https://hbase.apache.org/book.html#hfile</p>
<pre tabindex="0"><code>	StoreFile(HFile) 是 HBase 最终存储数据的介质
	Block：每个 HFile 由 N 个 Block 组成。
	KeyValue：每个Blokc是由多个KeyValue组成，KeyValue对象是数据存储的核心，KeyValue包装了一个字节数组，同时将偏移量offsets和lengths放入数组中，这个数组指定从哪里开始解析数据内容。
	注意：KeyValue 对象不跨 Block 存储，假如这里有一个 KeyValue 的大小为 8M，即使 Block-Size=64KB，当读取该KeyValue 的时候也是以一个连贯的 Block 进行读取。
	
	KeyValue 包装的字节数组的格式如下：
		Key Length：存储 Key 的长度，4 个字节。
		Value Length：存储 Value 的长度，4 个字节。
		Key（还可以被拆解）：存储数据的 Key，由 Row Key Length，Row Key，Column Family Length，		Column Family，Column Qualifier，TimeStamp，Key Type 组成。
		Value：存储 Column Qualifier 的值（用户写入的实际数据）。
	
	而 Key 又可以拆解成以下部分：
		Row Length：存储RowKey的长度，2字节
		Row：存储RowKey的实际内容，大小为Row Length
		Column Family Length：存储Column Family长度，1字节
		Column Family：存储Column Family实际内容
		Column Qualifier：存储Column Qualifier实际内容，
		Timestamp：存储时间戳，8字节
		KeyType：存储Key类型，1字节。Type 分为 Put、Delete、DeleteColumn、								DeleteFamilyVersion、DeleteFamily 等类型，标记这个 KeyValue 的类型
		
	由Data Block的结构可以看出，HBase中数据在最底层是以KeyValue的形式存储的，其中Key是一个比较复杂的复合结构。因为任意KeyValue中都包含Rowkey、Column Family以及Column Qualifier，因此这种存储方式实际上比直接存储Value占用更多的存储空间。这也是HB熊仔表结构设计时强调Rowkey、Column Family以及Column Qualifier尽可能设置短的根本原因。字节长，KV大磁盘消耗大。
</code></pre>

<h4 class="relative group">文件结构 
    <div id="%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>官方文档：https://hbase.apache.org/book.html#_hfile_format_2
截止目前，HFile 一共有 3 个版本，要深入了解 HFile 的话，还得从第一个版本开始看起。
HFile V1
	读取一个 HFile 时，会首先读取 Trailer，由 Trailer 指向数据块的 Data Block Index。Trailer 保存了每个段的起始位置（段的 Magic Number 用来做安全 Check），然后 Data Block Index 会被读取到内存中，这样，当检索某个 Key 时，不需要扫描整个 HFile，只需要从内存中找到 Key 所在的 Block，通过一次磁盘 IO 将整个 Block 读取到内存中，再找到需要的Key 即可
	Data Block 是 HBase I/O 的基本单元，为了提高效率，HRegionServer 提供了基于 LRU 的 Block Cache 机制。每个Block Data 块的大小可以在创建 Table 的时候通过 BLOCKSIZE 参数指定
	大号的 Block 有利于顺序 Scan，小号的 Block 利于随机查询。每个 Data 块除了开头的 Magic 以外就是一个个KeyValue 拼接而成，Magic 内容就是一些随机数字，目的是防止数据损坏。
	HFile 的 Data Block，Meta Block 通常采用压缩的方式存储。具体使用方式如下。
	
	第一版的Block Index非常简单，只有两个：Data Block Index，Meta Block Index
		Block Index包含：
			Offset (long)
			Uncompressed size (int)
			Key (a serialized byte array written using Bytes.writeByteArray)
				Key length as a variable-length integer (VInt)
				Key bytes
	Block Index的数量存放在Traniler，这样才能读取到Block Index的数据。这个版本BI有一个缺点，无法知道Block压缩后的数据大小，在这之后的解压过程是必要的。因此HFile读取器必须根据块之间的偏移量差来推断这个压缩的大小。所以在版本 2，解决了这个问题，在 Block Index 中增加了实际存储 Block 大小的数据（压缩后的数
据大小）。
</code></pre><pre tabindex="0"><code>HFile V2/V3
	接下来介绍 HFile V2 和 V3 版本，其中 V2 在 0.92 引入，V3 在 0.98 引入。HFile V1 版本除了刚才提到的问题以外，还发现在实际使用过程中占用内存较多，HFile V2 版本针对此也进行了优化，HFile V3 版本基本和 V2 版本相同，只是在Cell 层面添加了 Tag 数组的支持（增加安全方面特性，为 Cell 级别增加 ACL）。
	HFile V2 在接口层面做了兼容，在读 HFile 的时候，支持 v1 和 v2；在写 HFile 的时候，只会写 v2 版本的 HFile。
	　HFile V3 不和 V1、V2 兼容，因为在存储 KeyValue 时，会额外的存储 Tags，用于控制 ACL。
	　另一方面，V2用到了load-onopen概念，在打开HFile的时候，加载那些必要的信息，包括Trailer，Trailer里面记录的HFile的必要信息。而其他数据就可以在用到的时候，通过Trailer再解析出来。
	　
	HFile V2 主要分为四个部分：
	Scanned Block Section ：顺序扫描 HFile 时，会被读取的数据块。这个部分包含 3 种数据块：Data Block，Leaf Index Block 以及 BloomBlock。
		其中 Data Block 中存储用户的 KeyValue 数据，
		Leaf Index Block 中存储索引树的叶子节点数据，
		Bloom Block 中存储布隆过滤器相关数据。
	Non-Scanned Block Section ：顺序扫描 HFile 时，不会被读取的数据块。主要包括 Meta Block 和 Intermediate Level Data Index Blocks 两部分。
	Load-On-Open-Section ：这部分数据会在 HRegionServer 打开 HFile 时直接加载到内存中，包括 Root Data Index、Meta Index Block、FileInfo 和布隆过滤器 MetaBlock。
		FileInfo 是固定长度的数据块，主要记录了文件的一些统计元信息，比较重要的是 AVG_KEY_LEN 和
		AVG_VALUE_LEN，分别记录了该文件中所有 Key 和 Value 的平均长度。
		Root Data Index 表示 Data Blocke、Meta Block 和 Bloom Filter 的根索引。
		布隆过滤器 Metadata 记录了 HFile 中布隆过滤器的相关元数据。
	Trailer ：这部分主要记录了 HFile 的版本信息、其他各个部分的偏移值和寻址信息。
	
	HFile 文件由各种不同类型的 Block 构成，虽然这些 Block 的类型不同，但却拥有相同的数据结构。每个 Block 的大小可以在创建表列族的时候通过参数 BLOCKSIZE ＝&gt; &#39;65536&#39; 进行指定默认为 64K。大号的 Block 有利于顺序 Scan，小号的 Block 利于随机查询，因而需要权衡。HBase 将 Block 块抽象为一个统一的 HFileBlock。HFileBlock支持两种类型，一种类型支持 Checkum，一种不支持
	不支持 Checkum 的  HFileBlock 主要包括两部分：BlockHeader 和 BlockData。其中 BlockHeader 主要存储 Block 元数据，BlockData 用来存储具体数据。Block 元数据中最核心的字段是 BlockType 字段，用来标示该 Block 块的类型。HBase 中定义了 8 种 BlockType，每种 BlockType 对应的 Block 都存储不同的数据内容，有的存储用户数据，有的存储索引数据，有的存储 Meta 元数据。对于任意一种类型的 HFileBlock，都拥有相同结构的 BlockHeader，但是 BlockData 结构却不尽相同。
</code></pre><pre tabindex="0"><code>Trailer Block
	Trailer Block主要记录了HFile的版本信息，各个部分的偏移值和寻址信息。

HRegionServer在打开HFile时会加载所有HFile的Trailer，以及load-on-open到内存中。实际加载过程会先解析Trailer Block，再进一步加载load-on-open部分的数据。
	加载HFile Version版本信息，HBase 中 Version 包含 majorVersion 和 minorVersion 两部分，前者决定了 HFile 的主版本 V1、V2 还是 V3；后者在主版本确定的基础上决定是否支持一些微小修正，比如是否支持 Checksum 等。不同的版本使用不同的文件解析器对 HFile 进行读取解析。
	HBase会根据Version信息计算Trailer Block的大小，再根据Trailer Block大小加载整个HFile Trailer Block到内存中。Trailer Block 中包含很多统计字段
		TotalUncompressedBytes 表示 HFile 中所有未压缩的 KeyValue 总大小。
		NumEntries 表示 HFile 中所有 KeyValue 总数目。
		CompressionCodec 表示该 HFile 所使用的压缩算法，HBase 中压缩算法主要有 BZIP2、LZ4、LZO、SNAPPY、ZSTD 等，默认为 NONE，表示不使用压缩。可以在创建表列族的时候通过参数 COMPRESSION =&gt; &#39;SNAPPY&#39; 进行指定。
	Trailer Block另外两个重要的字段是LoadOnOpenDataOffset和LoadOnOpenDataSize，前者表示load-on-open Section在整个HFile文件中的偏移量，后者表示大小。根据此偏移量以及大小，HBase 会在启动后将 load-on-open Section 的数据全部加载到内存中。load-on-open 部分主要包括 FileInfo 模块、Root Data Index
模块以及布隆过滤器 Metadata 模块。
		FileInfo 是固定长度的数据块，主要记录了文件的一些统计元信息，比较重要的是 AVG_KEY_LEN 和
AVG_VALUE_LEN，分别记录了该文件中所有 Key 和 Value 的平均长度。
		Root Data Index 表示 Data Blocke、Meta Block 和 Bloom Filter 的根索引。
		布隆过滤器 Metadata 记录了 HFile 中布隆过滤器的相关元数据。
</code></pre><pre tabindex="0"><code>Data Block
	Data Block是HBase中文件读取的最小单元，Data Block中主要存储用户的KeyValue数据，而KV结构式HB存储的核心，HB中所有数据都是以KV结构存储在Data Block中。
	KeyValue 由 4 个部分构成，分别为 Key Length、Value Length、Key 和 Value。其中，Key Length 和 Value Length 是两个固定长度的数值，Value 是用户写入的实际数据，Key 是一个复合结构，由多个部分构成：Rowkey、Column Family、Column Qualifier、TimeStamp 以及 KeyType。其中，KeyType 有四种类型，分别是 Put、Delete、DeleteColumn 和DeleteFamily。
	由 Data Block 的结构可以看出，HBase 中数据在最底层是以 KeyValue 的形式存储的，其中 Key 是一个比较复杂的复合结构。因为任意 KeyValue 中都包含 Rowkey、Column Family 以及 ColumnQualifier，因此这种存储方式实际上比直接存储Value 占用更多的存储空间。这也是 HBase 系统在表结构设计时经常强调 Rowkey、Column Family 以及 ColumnQualifier 尽可能设置短的根本原因。
</code></pre><pre tabindex="0"><code>布隆过滤器相关的 Block
	布隆过滤器对 HBase 的数据读取性能优化至关重要。HBase 是基于 LSM 树结构构建的数据库系统，数据首先写入内存，然后异步 Flush 到磁盘形成文件。这种架构天然对写入友好，而对数据读取并不十分友好，因为随着用户数据的不断写入，系统会生成大量文件，用户根据 Key 获取对应的 Value，理论上需要遍历所有文件，在文件中查找指定的 Key，这无疑是很低效的做法。
	
　　使用布隆过滤器可以对数据读取进行相应优化，对于给定的 Key，经过布隆过滤器处理就可以知道该 HFile 中是否存在待检索 Key，如果不存在就不需要遍历查找该文件，这样就可以减少实际 IO 次数，提高随机读性能。布隆过滤器通常会存储在内存中，所以布隆过滤器处理的整个过程耗时基本可以忽略。
　　
　　HBase 会为每个 HFile 分配对应的位数组，KeyValue 在写入 HFile 时会先对 Key 经过多个 Hash 函数的映射，映射后将对应的数组位置为 1，get 请求进来之后再使用相同的 Hash 函数对待查询 Key 进行映射，如果在对应数组位上存在 0，说明该 get 请求查询的 Key 肯定不在该 HFile 中。当然，如果映射后对应数组位上全部为 1，则表示该文件中有可能包含待查询 Key，也有可能不包含，需要进一步查找确认（布隆过滤器的缺点）。
　　
　　可以想象，HFile 文件越大，里面存储的 KeyValue 值越多，位数组就会相应越大。一旦位数组太大就不适合直接加载到内存了，因此 HFile V2 在设计上将位数组进行了拆分，拆成了多个独立的位数组（根据 Key 进行拆分，一部分连续的 Key 使用一个位数组）。这样，一个 HFile 中就会包含多个位数组，根据 Key 进行查询时，首先会定位到具体的位数组，只需要加载此位数组到内存进行过滤即可，从而降低了内存开销。
　　
　　在文件结构上每个位数组对应 HFile 中一个 Bloom Block，因此多个位数组实际上会对应多个 Bloom Block。为了方便根据 Key 定位对应的位数组，HFile V2 又设计了相应的索引 Bloom Index Block。
　　
　　
　　　整个 HFile 中仅有一个 Bloom Index Block 数据块，位于 load-on-open 部分。Bloom Index Block 从大的方面看由两部分内容构成，其一是 HFile 中布隆过滤器的元数据基本信息，其二是构建了指向 Bloom Block 的索引信息。
　　Bloom Index Block 结构中 TotalByteSize 表示位数组大小，NumChunks 表示 Bloom Block 的个数，HashCount 表示Hash 函数的个数，HashType 表示 Hash 函数的类型，TotalKeyCount 表示布隆过滤器当前已经包含的 Key 的数目，TotalMaxKeys 表示布隆过滤器当前最多包含的 Key 的数目。
　　Bloom Index Entry 对应每一个 Bloom Block 的索引项，作为索引分别指向 Scanned block 部分的 Bloom Block，BloomBlock 中实际存储了对应的位数组。Bloom Index Entry 的结构见上图中间部分，其中 BlockKey 是一个非常关键的字段，表示该 Index Entry 指向的 Bloom Block 中第一个执行 Hash 映射的 Key。BlockOffset 表示对应 Bloom Block 在 HFile 中的偏移量。
　　因此，一次 get 请求根据布隆过滤器进行过滤查找需要执行以下三步操作：
　　	首先根据待查找 Key 在 Bloom Index Block 所有的索引项中根据 BlockKey 进行二分查找，定位到对应的 Bloom IndexEntry。
　　	再根据 Bloom Index Entry 中 BlockOffset 以及 BlockOndiskSize 加载该 Key 对应的位数组。
　　	对 Key 进行 Hash 映射，根据映射的结果在位数组中查看是否所有位都为 1，如果不是，表示该文件中肯定不存在该Key，否则有可能存在。
</code></pre><pre tabindex="0"><code>索引相关的 Block
	根据索引层级的不同，HFile 中索引结构分为两种： single-level 和 multi-level ，前者表示单层索引，后者表示多级索引，一般为两级或三级。HFile V1 版本中只有 single-level 一种索引结构，V2 版本中引入多级索引。随着HFile文件越来越大，Data Block越来越多，索引数据也越来越大，已经无法全部加载到内存中，多级索引可以只加载部分索引，从而降低内存使用空间。同步隆过滤器内存使用问题一样。
	V2 版本 Index Block 有两类：Root Index Block 和 NonRoot Index Block。NonRoot Index Block 又分为 Intermediate Index Block 和 Leaf Index Block 两种。HFile 中索引是树状结构，Root Index Block 表示索引数根节点，Intermediate Index Block 表示中间节点，Leaf Index Block 表示叶子节点，叶子节点直接指向实际 Data Block，
	
	需要注意的是，这三种 Index Block 在 HFile 中位于不同的部分
	Root Index Block 位于“load-on-open”部分，会在 HRegionServer 打开 HFile 时加载到内存中。
	Intermediate Index Block 位于“Non-Scanned block”部分，
	Leaf Index Block 位于“Scanned block”部分，Leaf Index Block 直接指向实际 Data Block。
	
	HFile 中除了 Data Block 需要索引之外，Bloom Block 也需要索引，Bloom 索引结构实际上采用了单层结构，Bloom Index Block 就是 Root Index Block 其中一种。对于 Data Block，由于 HFile 刚开始数据量较小，索引采用单层结构，只有 Root Index Block 一层索引，直接指向Data Block。当数据量慢慢变大，Root Index Block 大小超过阈值之后，索引就会分裂为多级结构，由一层索引变为两层，根节点指向叶子节点，叶子节点指向实际 Data Block，如果数据量再变大，索引层级就会变为三层。
	
Root Index Block
	Root Index Block 表示索引树根节点索引块，既可以作为 Bloom Block 的直接索引，也可以作为 Data Block 多极索引树的根索引。对于单层和多级这两种索引结构，对应的 Root Index Block 结构略有不同，单层索引结构是多级索引结构的一种简化场景。本节以多级索引结构中的 Root Index Block 为例进行分析。
	Index Entry 表示具体的索引对象，每个索引对象由 3 个字段组成：Block Offset 表示索引指向 Data Block 的偏移量，BlockDataSize 表示索引指向 Data Block 在磁盘上的大小，BlockKey 表示索引指向 Data Block 中的第一个 Key。　除此之外，还有另外 3 个字段用来记录 MidKey 的相关信息，这些信息用于在对 HFile 进行 Split 操作时，快速定位HFile 的切分点位置。需要注意的是单层索引结构和多级索引结构相比，仅缺少与 MidKey 相关的这三个字段。
　　Root Index Block 位于整个 HFile 的“load-on-open”部分，因此会在 HRegionServer 打开 HFile 时直接加载到内存中。此处需要注意的是，在 Trailer Block 中有一个字段为 DataIndexCount，表示 Root Index Block 中 Index Entry 的个数，只有知道 Entry 的个数才能正确地将所有 Index Entry 加载到内存。
　　
NonRoot Index Block
	当 HFile 中 Data Block 越来越多，单层结构的根索引会不断膨胀，超过一定阈值之后就会分裂为多级结构的索引结构。多级结构中根节点是 Root Index Block。而索引树的中间层节点和叶子节点在 HBase 中存储为 NonRoot Index Block，但从 Block 结构的视角分析，无论是中间节点还是叶子节点，其都拥有相同的结构。
	和 Root Index Block 相同，NonRoot Index Block 中最核心的字段也是 IndexEntry，用于指向叶子节点块或者 Data Block。不同的是，NonRoot Index Block 结构中增加了 Index Entry 的内部索引 Entry Offset 字段，Entry Offset 表示IndexEntry 在该 Block 中的相对偏移量（相对于第一个 Index Entry），用于实现 Block 内的二分查找。通过这种机制，所有非根节点索引块（包括 Intermediate Index Block 和 Leaf Index Block）在其内部定位一个 Key 的具体索引并不是通过遍历实现，而是使用二分查找算法，这样可以更加高效快速地定位到待查找 Key。
</code></pre>

<h4 class="relative group">Why Fast 
    <div id="why-fast" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#why-fast" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>分层索引
	无论是 Data Block Index 还是 Bloom Filter，都采用了分层索引的设计。Data Block 的索引，在 HFile V2 中最多可支持三层索引：
	最底层的 Data Block Index 称之为 Leaf Index Block，可直接索引到 Data Block；
	中间层称之为 Intermediate Index Block，
	最上层称之为 Root Data Index，Root Data index 存放在 Load-on-open Section 区域，会在 HRegionServer 打开 HFile时加载到内存中。
	
	最基本的额索引流程为：由Root Data Index索引到Intermediate Block Index，再由Intermediate Block Index 索引到lesf Index Block，最后由Leaf INdex Block 查找到对应的Data Block。最后由Leaf Index Block查找到对应的Data Block。在实际场景中，Intermediate Block Index基本上用不到。因此，索引逻辑被简化为：由 Root Data Index 直接索引到 Leaf Index Block，再由 Leaf Index Block 查找到的对应的 Data Block。
	
交叉存储
	HFile V1 的设计导致了 HRegionServer 启动时间过长，需要加载很大的数据量，比如大量的 Bloom Filter，大量的Block Index。为了解决这个问题，V2 使得 HFile 增加了新特性，把 Bloom Filter 和 Block Index 打散，写到多个 Block 中去，这样就减少了 HFile 写入时候的内存 Offset 记录。并且这些打散的 Block Index 会有预定的长度。
	Bloom Filter 包含 Bloom 元数据(Hash 函数类型，Hash 函数个数等)与位数组(Bloom Data)，为了避免每一次读取时加载所有的 Bloom Data，HFile V2 中将 Bloom Data 部分分成了多个小的 Bloom Block。
	Bloom Data 数据也被当成一类 Inline Block，与 Data Block、Leaf Index Block 交叉存在，而关于 Bloom Filter 的元数据与多个 Bloom Block 的索引信息，也被存放在 Load-On-Open Section 部分。
	需要注意的是，关于 Bloom Filter 的配置类型信息，保存在 FileInfo 部分，可以在创建表列族的时候通过参数BLOOMFILTER =&gt; &#39;ROW&#39; 进行指定。共包含三种类型：
		不启用；
		基于 Row 构建 Bloom Filter；
		基于 Row + Column 构建 Bloom Filter
		
按需读取
无论是 Data Block 的索引数据，还是 Bloom Filter 数据，都被拆成了多个 Block，基于这样的设计，无论是索引数据，还是 Bloom Filter，都可以按需读取，避免在读取阶段一次读入大量的数据，有效降低时延。
</code></pre>

<h3 class="relative group">HLog 
    <div id="hlog" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hlog" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	一个HRegionServer只有一个HLog文件。负责记录数据的操作日志，当 HBase 出现故障时可以进行日志重放、故障恢复。例如磁盘掉电导致 MemStore 中的数据没有持久化存储到 StoreFile，这时就可以通过 HLog 日志重放来恢复数据。
	HLog 文件就是一个普通的 Hadoop Sequence File，Sequece File 的 Key 是 HLogKey 对象，Sequece File 的 Value 是HBase 的 KeyValue 对象，即本次的操作。
　　HLogKey 中记录了写入数据的归属信息，除了 Table 和 HRegion 名称外，同时还包括 Sequence Number 和
Timestamp：
	Timestamp：写入时间。
	Sequence Number：起始值为 0，或者是最近一次存入文件系统中的 Sequence Number。
	数据被写入 WAL 后，会被加入到 MemStore 即写缓存。然后服务端就可以向客户端返回 ack 表示写数据完成。
</code></pre>

<h3 class="relative group">HDFS 
    <div id="hdfs" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#hdfs" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>　HDFS 为 HBase 提供底层数据存储服务，同时为 HBase 提供高可用支持。HBase 将 HLog 存储在 HDFS 上，当服务器发生异常宕机时，可以重放 HLog 来恢复数据。
　比如：MySQL 数据直接落入磁盘，HBase 数据落入 HDFS，HDFS 数据落入磁盘。
</code></pre>

<h2 class="relative group">BlockCache 
    <div id="blockcache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#blockcache" aria-label="锚点">#</a>
    </span>        
    
</h2>
<pre tabindex="0"><code>	为了提升读取性能，HBase实现了已汇总读缓存结构BlockCacche，客户端读取某个Block,首先会检查该Block是否存在于BlockCache，如果存在就直接加载出来，如果不存在就去 HFile 文件中加载，加载出来后再放到 BlockCache中，后续同一请求或者邻近数据查找请求可以直接从内存中获取，以避免昂贵的 IO 开销。BlockCache 主要用来缓存 Block。
	HBase 在实现中提供了两种缓存结构：MemStore 和 BlockCache。MemStore 作为 HBase 的写缓存，保存着数据的最近一次更新；BlockCache 作为 HBase 的读缓存，保存着最近被访问的数据块。 Block 是 HBase 中最小的数据读取单元，即数据从 HFile 中读取都是以 Block 为最小单元执行的。BlockCache 是 RegionServer 级别的，一个 RegionServer 只有一个 BlockCache，在 RegionServer 启动时完成
BlockCache 的初始化工作。

	到目前为止，HBase 先后实现了 3 种 BlockCache 方案：
	LRUBlockCache ：最早的实现方案，也是默认的实现方案（LRUBlockCache + BucketCache）；
	SlabCache ：HBase 0.92 版本实现的第二种方案，参见 HBase-4027；
	BucketCache ：HBase 0.96 之后官方提供的另一种可选方案，参见 HBase-7404。
	这 3 种方案的不同之处主要在于内存管理模式，其中 LRUBlockCache 是将所有数据都放入 JVMHeap 中，交给 JVM进行管理。而后两种方案采用的机制允许将部分数据存储在堆外。BlockCache 默认是开启的，不需要做额外的事情去开启 BlockCache。如果想让某个列族不使用 BlockCache，可以通过以下命令关闭它：
		create &#39;my-table&#39;, {NAME =&gt; &#39;my-cf&#39;, BLOCKCACHE =&gt; &#39;false&#39;}
		alter &#39;my-table&#39;, CONFIGURATION =&gt; {NAME =&gt; &#39;my-cf&#39;, BLOCKCACHE =&gt; &#39;false&#39;}
</code></pre>

<h3 class="relative group">LRUBlockCache 
    <div id="lrublockcache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#lrublockcache" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	LRUBlockCache 是完全基于 JVM heap 的 LRU 方案，在 0.92 版本之前只有这种 BlockCache 的实现方案，LRU 就是Least Recently Used，即近期最少使用算法。读出来的Block会被放到BlockCache中待下次查询使用，当缓存满了之后会根据LRU的算法来淘汰Block。每次访问数据都会将其放在我们的队首，如果需要淘汰数据，只需要好淘汰队尾的即可这里有个问题，如果有个数据在 1 分钟内被访问了 1000 次，接下来 1 分钟没有访问该数据，但是有其他的数据被大量访问，就会导致这个热点数据被淘汰。
	
# Java API 设置 in-memory
HColumnDescriptor.setInMemory(true);
# Shell API 设置 in-memory
create  &#39;t&#39;, {NAME =&gt; &#39;f&#39;, IN_MEMORY =&gt; &#39;true&#39;}
</code></pre><p>​	LRUBlockCache被分为三个区域：</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>占用比例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>single-access</td>
<td>25%</td>
<td>单次读取区域。Block被独处课后先放到这个区域，当被读到多次后会升级到写一个区域</td>
</tr>
<tr>
<td>multi-accsss</td>
<td>50%</td>
<td>多次读取区域。缓存在单次读取区域的Block被多次访问会升级在这个区域</td>
</tr>
<tr>
<td>in-memory</td>
<td>25%</td>
<td>这个区域跟Block被访问了几次没有关系。只存放被设置了IN_MEMORY =&gt;&lsquo;true&rsquo;</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>　列族被设置为 IN-MEMORY 并不是意味着这个列族是存储在内存中的，这个列族依然是跟别的列族一样存储在硬盘
上。一般Block被第一次读出后是放到single-access，只有当被访问多次以后才会放到multi-access，带有IN_MEMORY的BLock一开始就会被放在in_memory区域。这个区域的缓存有最高的存活时间，在需要淘汰Block的时候，这个区域的Block是最后被考虑的，这个属性仅仅是为了BlockCache而创造的。

	目前 BlockCache 的堆内内存方案就只有 LRUBlockCache，可以通过将 hfile.block.cache.size 设置为 0 来关闭该方案，但是不推荐。相关配置如下，默认为 0.4，表示分配给 StoreFile 使用的块缓存的最大堆(-Xmx setting)。
&lt;property&gt;
  &lt;name&gt;hfile.block.cache.size&lt;/name&gt;
  &lt;value&gt;0.4&lt;/value&gt;
&lt;/property&gt;
	计算 HBase 中有多少内存可用于缓存的方法如下：number of region servers * heap size(-Xms1024m初始堆和-Xmx1024m最大堆) * hfile.block.cache.size * 0.99
</code></pre>

<h3 class="relative group">BucketCache 
    <div id="bucketcache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bucketcache" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">基本介绍 
    <div id="%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	BuckCache借鉴了SlabCache的创意，也用上了堆内存，分配了14中区域。
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.bucket.sizes&lt;/name&gt;
  &lt;value&gt;4096,8192&lt;/value&gt;
&lt;/property&gt;
	BucketCache的存储不一定要使用堆外内存，是可以自由自在的三种存储介质直接选择：堆外（offheap）、文件（file）、mmaped file（memory-mapped file内存映射文件）。通过设置 hbase.bucketcache.ioengine 为 offheap、file 或者mmaped file 来配置，如下。
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.ioengine&lt;/name&gt;
  &lt;value&gt;offheap&lt;/value&gt;
&lt;/property&gt;
	每个 Bucket 的大小上限为最大尺寸的 Block * 4，比如可以容纳的最大的 Block 类型是 512KB，那么每个 Bucket 的大小就是 512KB * 4 = 2048KB。系统一启动BucketCache就会把可用的存储空间按照每个Bucket的大小上限均分为多个Bucket。如果划分完的数量比种类还少会报错，因为每一个类型至少要有一个Bucket。
	
	BuckCache可以自己划分内存空间，自己管理内存空间，Block放进去的时候考虑offset偏移量的，所以内存碎片少，GC时间段。使用BucketCache的好处：
		可以使用SSD硬盘的缓存策略。
		极大改进了SlabCache使用率低的问题
		配置灵活，适用多种场景。
</code></pre>

<h4 class="relative group">相关配置 
    <div id="%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>BucketCache 相关配置项如下：
hbase.bucketcache.ioengine ：使用的存储介质，可选值为offheap、file、mmaped file。默认为offheap。
hbase.bucketcache.combinedcache.enabled ：是否打开组合模式（CombinedBlockCache）。默认为 true。
hbase.bucketcache.size ：BucketCache 所占的大小，如果设置为 0.0~1.0，则代表了占堆内存的百分比。如果是大于 1 的值，则代表实际的 BucketCache 的大小，单位为 MB。为什么要一个参数两用这么别扭呢？因为 BucketCache既可以用于堆内存，还可以用于堆外内存和硬盘。默认值为 0.0 ，即关闭 BucketCache。
hbase.bucketcache.bucket.sizes ：定义所有 Block 种类，默认为 14 种，种类之间用逗号分隔。单位为 B，每一种类型必须是 1024 的整数倍，否则会报异常： java.io.I0Exception: Invalid HFile block magic 。
-XX:MaxDirectMemorySize ：这个参数不是在 hbase-site.xml 文件中配置的，而是 JVM 启动的参数。如果你不配置这个参数，JVM 会按需索取堆外内存；如果你配置了这个参数，你可以定义 JVM 可以获得的堆外内存上限。显而易见的，这个参数值必须比 hbase.bucketcache.size 大。
</code></pre>

<h3 class="relative group">Combined BlockCahce（组合模式） 
    <div id="combined-blockcahce%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#combined-blockcahce%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	具体地说就是把不同类型的 Block 分别放到 LRUCache 和 BucketCache 中。
		IndexBlock 和 BloomBlock 会被放到 LRUCache 中；
		DataBlock 被直接放到 BucketCache 中，所以会先去 LRUCache 查询以下，然后再去 BucketCache 查询真正的数据。
	　其实这种实现是一种更合理的二级缓存，数据从一级缓存到二级缓存最后到硬盘，数据是从小到大，存储介质也是由快到慢。考虑到成本和性能的组合，比较合理的介质是：LRUCache 使用内存 =&gt; BuckectCache 使用 SSD =&gt; HFile 使用机械硬盘
	　提示：设置 hbase.bucketcache.ioengine，开启 hbase.bucketcache.combinedcache.enabled 且 hbase.bucketcache.size 0 即可启用 Combined BlockCache。
	　
	　因为 BucketCache 自己控制内存空间，碎片比较少，所以 GC 时间大部分都比 LRUCache 短。
	　在缓存全部命中的情况下，LRUCache 的吞土量是 BucketCache 的两倍；在缓存基本命中的情况下，LRUCache 的吞吐量跟 BucketCache 基本相等。
	　读写延迟，IO 方面两者基本相等。
	　缓存全部命中的情况下，LRUCache 比使用 file 模式的 BucketCacheCPU 占用率低一倍，但是跟其他情况下差不多。
	　从整体上说 LRUCache 的性能好于 BucketCache，但由于 Full GC 的存在，在某些时刻 JVM 会停止响应，造成服务不可用。所以适当的搭配 BucketCache 可以缓解这个问题。
</code></pre>

<h4 class="relative group">BucketCache 中 Block 的缓存写入/读取流程 
    <div id="bucketcache-%E4%B8%AD-block-%E7%9A%84%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#bucketcache-%E4%B8%AD-block-%E7%9A%84%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>读取 Block 的流程
	RAMCache 是一个存储 blockKey 和 Block 对应关系的 HashMap。
	WriteThead 是整个 Block 写入的中心枢纽，主要负责异步地将 Block 写入到内存空间。
	BucketAllocator 主要实现对 Bucket 的组织管理，为 Block 分配内存空间。
	IOEngine 是具体的内存管理模块，将 Block 数据写入对应地址的内存空间。
	BackingMap 也是一个 HashMap，用来存储 blockKey 与对应物理内存偏移量的映射关系，并且根据 blockKey 定位具体的 Block。图中实线表示 Block 写入流程，虚线表示 Block 缓存读取流程。
	
Block 缓存写入流程
	将 Block 写入 RAMCache。实际实现中，HBase 设置了多个 RAMCache，系统首先会根据 blockKey 进行 hash，根据hash 结果将 Block 分配到对应的 RAMCache 中。
	WriteThead 从 RAMCache 中取出所有的 Block。和 RAMCache 相同，HBase 会同时启动多个 WriteThead 并发地执行异步写入，每个 WriteThead 对应一个 RAMCache。
	每个 WriteThead 会遍历 RAMCache 中所有 Block，分别调用 bucketAllocator 为这些 Block 分配内存空间。
	BucketAllocator 会选择与 Block 大小对应的 Bucket 进行存放，并且返回对应的物理地址偏移量 offset。
	WriteThead 将 Block 以及分配好的物理地址偏移量传给 IOEngine 模块，执行具体的内存写入操作。
写入成功后，将 blockKey 与对应物理内存偏移量的映射关系写人 BackingMap 中，方便后续查找时根据 blockKey 直接定位。

Block 缓存读取流程
	首先从 RAMCache 中查找。对于还没有来得及写入 Bucket 的缓存 Block，一定存储在 RAMCache 中。
	如果在 RAMCache 中没有找到，再根据 blockKey 在 BackingMap 中找到对应的物理偏移地址量 offset。
	根据物理偏移地址 offset 直接从内存中查找对应的 Block 数据。
</code></pre>

<h3 class="relative group">压缩 BlockCache 
    <div id="%E5%8E%8B%E7%BC%A9-blockcache" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%8E%8B%E7%BC%A9-blockcache" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	HBASE-11331 引入了惰性 BlockCache 解压缩，通常称为压缩 BlockCache。启用压缩 BlockCache 时，数据和编码数据块会以它们在磁盘上的格式的形式缓存在 BlockCache 中，而不是在缓存之前解压缩和解密。与默认的模式不同点在于：默认情况下，在缓存一个数据块时，会先解压缩、解密，然后存入缓存（因为数据块是从 HDFS 取）。而惰性 BlockCache解压缩会直接将数据块存入缓存。
　　对于托管的数据量超过缓存容量的 HRegionServer，启用此功能并使用 SNAPPY 压缩，实验证明：吞吐量增加 50%，平均延迟改善 30%，同时垃圾回收增加 80%，但是会增加总体 CPU 负载 2%。有关性能如何衡量和实现的更多详细信息，请参阅 HBASE-11331。对于托管的数据可以轻松适应缓存的 HRegionServer，或者如果您的工作负载对额外的 CPU 或垃圾回收负载比较敏感，可能只会获得较少的好处。
　　BlockCache 的压缩功能默认是关闭的，要启用该功能，请在所有 HRegionServer 的 hbase-site.xml 中将
hbase.block.data.cachcompressed 设置为 true。
</code></pre>

<h2 class="relative group">交互方式 
    <div id="%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h2 class="relative group">读写流程 
    <div id="%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h2>
<pre tabindex="0"><code>	HBase中表的数据量能达到tb;pb级别，但大多数情况下能读取速度能达到毫秒级。通用做法是数据保持有序并尽可能将数据保存在内存中。数据存储上HBase将表切分成一个个的HRegion托管到HRegionServer上，类似关系型数据库的分区表，但比关系型数据库分区分库易用。
</code></pre>

<h3 class="relative group">三层索引 
    <div id="%E4%B8%89%E5%B1%82%E7%B4%A2%E5%BC%95" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E4%B8%89%E5%B1%82%E7%B4%A2%E5%BC%95" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>HBase 0.96 以前
	整个流程为：Client -&gt; Zookeeper -&gt; ROOT -&gt; .META. -&gt; 用户表的HRegion
	内部维护了两个特殊的表-ROOT-和.META.表，查找各种表的HRegion位置，这两张特殊的表也像HBase中的其他表一样会切分成多个HRegioin。-ROOT-表比.META.更特殊，不会切分超过一个HRegion，这样保证只需跳转三次就能定位到任意HRegion。
		-ROOT-：记录.META.表的HRegion信息
		.META.：记录用户表的HRegion数据
	而-ROOT-表的HRegion位置信息存放在ZooKeeper中，通过ZooKeeper可以找到-ROOT-的HRegion托管的HRegionServer。再通过-ROOT-找到.META.表的HRegion位置。.META.存放用户表的HRegion信息。
	
	当用户的表特别大时，用户的表的 HRegion 也会非常多。.META. 表存储了这些 HRegion 信息，也会变得非常大，这时.META. 自己也需要划分成多个 HRegion，托管到多个 HRegionServer 上。这时就出现了一个问题：当 .META. 被托管在多个RegionServer 上，如何去定位 .META. 呢？ HBase 的做法是用另外一个表来记录 .META. 的 HRegion 信息，就和.META.记录用户的表的 HRegion 一样，这个表就是 -ROOT- 表。ROOT- 表永远只有一个 HRegion，也就是说只会存放在一台 HRegionServer 上，这个信息至关重要，是所有客户端定位 HRegion 的入口，所以这个映射信息存储在 ZooKeeper 上面。
</code></pre><pre tabindex="0"><code>HBase 0.96 以后
	-ROOT-表被移除，.META.表的HRegion位置信息存放在ZooKeeper中，并将.META.表改名为hbase：meta
	整个流程为：Client -&gt; ZooKeeper -&gt; hbase：meta -&gt; 用户的表的 HRegion
	
hbase:meta表结构：
	rowkey:表名，格式：表名，起始键，Hregion的时间戳.Encode编码
	table:state：表的状态，启用还是禁用
	info:state：HRegion的状态，正常状态下为OPEN
	info:server：HregionServer的地址和端口
	info:serverstartcode：HregionServer启动的13位时间戳
	info:sn：server和serverstartcode的组合
	info:seqnumDuringOpen：HRegion在线时长的二进制串
	info:regioninfo：HRegion的详细信息，如ENCODE、NAME、STARTKEY、ENDKEY等
</code></pre>

<h3 class="relative group">读取数据流程 
    <div id="%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>


<h4 class="relative group">数据组织 
    <div id="%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>	HBase 数据的组织架构，首先 Table 横向切割为多个 HRegion ，按照一个列族的情况，每一个HRegion 中包含一个 MemStore 和多个HFile文件。
	首先，在 HRegionServer 内部，会把读取可能涉及到的所有组件都初始化为对应的 Scanner 对象，针对 HRegion 的读取，封装为一个 RegionScanner 对象，而一个列族对应一个 Store，对应封装为 StoreScanner，在 Store 内部，MemStore则封装为 MemStoreScanner，每一个 HFile 都会封装为 StoreFileScanner。最后数据的查询就会落在 MemStoreScanner 和StoreFileScanner 上。
　　这些 Scanner 首先根据 Scan 的 TimeRange 和 RowKey Range 会过滤掉一些，剩下的 Scanner 在 HRegionServer 内部组成一个最小堆 KeyValueHeap，该数据结构核心为一个 PriorityQueue 优先级队列，队列里按照 Scanner 指向的 KeyValue 排序。
　　
　　Client 访问 ZooKeeper，获取 hbase:meta 所在 HRegionServer 的节点信息；
	Client 访问 hbase:meta 所在的 HRegionServer，获取 hbase:meta 记录的元数据后先加载到内存中，然后再从内存中查询出 RowKey 所在的 HRegion （HRegion 所在的 HRegionServer）；
	Client 对 RowKey 所在的 HRegion 对应的 HRegionServer 发起读取数据请求；
	HRegionServer 构建 RegionScanner（需要查询的 RowKey 分布在多少个 HRegion 中就需要构建多少个
RegionScanner），用于对该 HRegion 的数据检索；
	RegionScanner 构建 StoreScanner（HRegion 中有多少个 Store 就需要构建多少个 StoreScanner，Store 的数量取决于Table 的 ColumnFamily 的数量），用于对该列族的数据检索；
	所有的 StoreScanner 合并构建最小堆（已排序的完全二叉树）StoreHeap:PriorityQueue；
	StoreScanner 构建一个 MemStoreScanner 和一个或多个 StoreFileScanner（数量取决于 StoreFile 数量）；
	过滤掉能够确定所要查询的 RowKey 一定不在的 StoreFileScanner 或 MemStoreScanner（布隆过滤器）；
	经过筛选后留下的Scanner开始做读取数据的准备，将对应的 StoreFile 定位到满足的 RowKey 的起始位置；
	将所有的 StoreFileScanner 和 MemStoreScanner 合并构建最小堆 KeyValueHeap:PriorityQueue，排序的规则按照KeyValue 从小到大排序；从 KeyValueHeap:PriorityQueue 中经过一系列筛选后一行行的得到需要查询的 KeyValue。
	
	默认情况下：先从BlockCache查找数据，没有再从MemStore上查找，还没有再到StoreFile上查找。其中StoreFile的扫描会先舒勇Bloom Filter过滤那些不可能符合条件的HFile，然后使用Data Blokc Index快读定位Cell，并将其加载到BlockCache中，然后从BlockCache中读取，目的是为了加快后续的查询，然后再返回结果给客户端。
</code></pre>

<h4 class="relative group">查询过程 
    <div id="%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h4>
<pre tabindex="0"><code>第一步
	现在我们根据主键 RowKey 来查询对应的记录，通过 hbase:meta 表可以帮我们迅速定位到该记录所在的数据节点，以及数据节点中的 HRegion，由于记录在 1 个 HRegion 中，所以我们只需要查询这 2G 的 HRegion，就可以找到对应的记录。
第二步
	由于 HBase 存储数据是按照列族存储的。其中的族列是分开存储的，我们只需要遍历相对应的族列就可以找到对应数据。
第三步
	1 个列族在 HDFS 中会包含 1 个或者多个 HFile（StoreFile），由于 HBase 内存 Flush 到磁盘中的数据是排好序的，要查询的记录有可能在最前面，也有可能在最后面，按平均来算，我们只需遍历 2.5 个 HFile 就可以找到对应的记录。
第四步
	每个 HFile 中，是以键值对（Key/Value）方式存储，只要遍历文件中的 Key 位置并判断符合条件即可。一般 Key 是有限的长度。
第 N 步
	HFile 继续划分，有 Data Block，Data Block Index，Trailler 等组成，已经定位到 RowKey 所在的 HFile 时，会先读取HFile 的 Trailer 的信息以获取 Data Block Index 的位置。Data Block Index 的 Key 就是 Data Block 的 RowKey，所以通过 DataBlock Index 的 Key 就能精确的定位到要检索的 RowKey 在哪个 Data Block 上，然后直接将该 Data Block 读取到内存，需要注意的是这里的 Data Block 已经很小了（默认是 64K，不同于 HDFS 上的 Block 默认为 128M，HBase 的 HFile 中的 Block 要小的多）这样子足以读取该 Block 到内存中，将该 Block 进行遍历就能获取到需要的 RowKey 并取出数据。因为这里的Block 只有 64K，所以遍历会非常迅速。这就是为什么 HFile 的 Data Block 要设置的如此之小的原因。
	
总结
	正因为以上流程，即使数据量剧增，也不会导致 HBase 的查询性能下降。同时，HBase 是一个面向列存储的数据库（列族机制），当表字段非常多时，可以把其中一些字段独立出来放在一部分机器上，而另外一些字段放到另一部分机器
上，分散存储，分散列查询。
　　正是由于这样复杂的存储结构和分布式的存储方式，保证了 HBase 海量数据下的查询效率。
</code></pre>

<h3 class="relative group">写入数据流程 
    <div id="%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>	Client 访问 ZooKeeper，获取 hbase:meta 所在 HRegionServer 的节点信息；
	Client 访问 hbase:meta 所在的 HRegionServer，获取 hbase:meta 记录的元数据后先加载到内存中，然后再从内存中查询出 RowKey 所在的 HRegion （HRegion 所在的 HRegionServer）；
	Client 对 RowKey 所在的 HRegion 对应的 HRegionServer 发起写入数据请求；
	建立连接后，首先将 DML 要做的操作写入到日志 HLog；
	然后将数据的修改更新到 MemStore 中，本次操作结束。一个 HRegion 由多个 Store 组成，一个 Store 对应一个列族，Store 包括位于内存中的 Memstore 和位于磁盘的 StoreFile，写操作先写入 MemStore；
	当 MemStore 数据达到阈值后（默认 128M），创建一个新的 MemStore；
	旧的 MemStore 将刷写为一个独立的StoreFile（HRegionServer会启动FlushCache进程写入StoreFile）并存放到HDFS，最后删除 HLog 中的历史数据。
	
	当 StoreFile 文件的数量增长到一定阈值后，系统会进行合并（次/小 Minor Compaction、主/大 Major Compaction）；在合并过程中会进行版本合并和删除工作，形成更大的 StoreFile；当一个 HRegion 所有 StoreFile 的大小和数量超过一定阈值后，会把当前的 HRegion 分割为两个，并由 HMaster 分配到相应的 HRegionServer 服务器，实现负载均衡。
</code></pre>

<h2 class="relative group">数据刷写 
    <div id="%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99" aria-label="锚点">#</a>
    </span>        
    
</h2>


<h3 class="relative group">触发时机 
    <div id="%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA" aria-label="锚点">#</a>
    </span>        
    
</h3>
<pre tabindex="0"><code>内存阈值
	HRegion 中的每个 MemStore 占用的内存超过相关阈值 hbase.hregion.memstore.flush.size 时会触发刷写，默认为 128MB。如果我们的数据增加得很快，到了4倍（默认，可修改）除了触发 MemStore 刷写之外，HBase 还会在刷写的时候阻塞所有写入该Store 的请求。
	
内存总和
	整个 HRegionServer 的 MemStore 占用内存总和大于相关阈值时会触发刷写。如果达到了 HRegionServer 级别的刷写，当前 HRegionServer 的所有写操作将会被阻塞，这个阻塞可能会持续到分钟级别。
	HBase 为 HRegionServer 所有的 MemStore 分配了一定的写缓存，大小等于 hbase_heapsize(HRegionServer 占用的堆内存大小) * hbase.regionserver.global.memstore.size(默认为 0.4)。
　　相关阈值计算公式为： hbase_heapsize * hbase.regionserver.global.memstore.size *
hbase.regionserver.global.memstore.size.lower.limit(默认为 0.95) = MAX_SIZE 。例如：HBase 堆内存总共是 32G，MemStore 占用内存为：32 * 0.4 * 0.95 = 12.16G 将触发刷写。

日志阈值
	HBase 使用了 WAL 机制（日志先行），当数据到达 HRegion 时是先写入日志的，然后再被写入到 MemStore。如果日志的数量越来越大，这就意味着 MemStore 中未持久化到磁盘的数据越来越多。当 HRegionServer 挂掉的时候，恢复时间将会变得很长，所以有必要在日志到达一定的数量时进行一次刷写操作。相关公式为：Math.max(32, hbase_heapsize *hbase.regionserver.global.memstore.size * 2 / logRollSize)。
	
定期刷写
	当定时器到达 hbase.regionserver.optionalcacheflushinterval （默认值 3600000 毫秒，即 1 小时）时，HBase 会自动触发刷写。一般建议调大，比如 10 小时，因为很多场景下 1 小时 Flush 一次会产生很多小文件，一方面导致Flush 比较频繁，另一方面导致小文件很多，影响随机读性能。
	
更新频率
	如果 HBase 的某个 HRegion 更新的很频繁，而且既没有达到自动刷写阀值，也没有达到内存的使用限制，但是内存中的更新数量已经足够多，比如超过 hbase.regionserver.flush.per.changes 参数配置，默认为 30000000 次，也会触发刷写。
	
手动刷写
	Shell 中通过 flush 命令
	hbase&gt; flush &#39;TABLENAME&#39;
	hbase&gt; flush &#39;REGIONNAME&#39;
	hbase&gt; flush &#39;ENCODED_REGIONNAME&#39;
	hbase&gt; flush &#39;REGION_SERVER_NAME&#39;
	
注意
	以上所有条件触发的刷写操作最后都会检查对应的 Store 包含的 StoreFiles 文件数是否超过
hbase.hstore.blockingStoreFiles 参数配置的个数，默认为 16。如果满足这个条件，那么当前刷写会被推迟到
hbase.hstore.blockingWaitTime 参数设置的时间后再刷写。
　　如果是阻塞刷写，HBase 还会请求 Compaction 压实处理或者 Split 分割操作。
</code></pre>

<h3 class="relative group">刷写策略 
    <div id="%E5%88%B7%E5%86%99%E7%AD%96%E7%95%A5" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100">
        <a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700"
            style="text-decoration-line: none !important;" href="#%E5%88%B7%E5%86%99%E7%AD%96%E7%95%A5" aria-label="锚点">#</a>
    </span>        
    
</h3>

        </div>
        
        

        
        

          
      </div>
     
      
      
        
        
          
          
        
      <script>
        var oid = "views_docs\\Hbase\\Hbase.md"
        var oid_likes = "likes_docs\\Hbase\\Hbase.md"
      </script>
      
      
      
      <script type="text/javascript" src="/js/page.min.0860cf4e04fa2d72cc33ddba263083464d48f67de06114529043cb4623319efed4f484fd7f1730df5abea0e2da6f3538855634081d02f2d6e920b956f063e823.js" integrity="sha512-CGDPTgT6LXLMM926JjCDRk1I9n3gYRRSkEPLRiMxnv7U9IT9fxcw31q&#43;oOLabzU4hVY0CB0C8tbpILlW8GPoIw=="></script>
  
    </section>
  <footer class="pt-8 max-w-prose print:hidden">

    
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600" />
      <div class="flex justify-between pt-3">
        <span>
          
            <a class="flex group mr-3" href="/docs/hive/hive/">
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  ></span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="0001-01-01 00:00:00 &#43;0000 UTC">0001-01-01</time>
                  
                </span>
              </span>
            </a>
          
        </span>
        <span>
          
            <a class="flex text-right group ml-3" href="/docs/hadoop_hdfs/hadoop_hdfs/">
              <span class="flex flex-col">
                <span
                  class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500"
                  ></span
                >
                <span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400">
                  
                    <time datetime="0001-01-01 00:00:00 &#43;0000 UTC">0001-01-01</time>
                  
                </span>
              </span>
              <span
                class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400"
                >&rarr;</span
              >
              <span
                class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400"
                >&larr;</span
              >
            </a>
          
        </span>
      </div>
    </div>
  


    
  </footer>
</article>

      <div id="top-scroller" class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0">
  <a href="#the-top"
    class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="返回顶部" title="返回顶部">
    &uarr;
  </a>
</div>
    </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">

    
    
    <p class="text-sm text-neutral-500 dark:text-neutral-400">
      &copy;
      2024
      KV先生
    </p>
    

    
    
    <p class="text-xs text-neutral-500 dark:text-neutral-400">
      
      
      由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
        href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a> 强力驱动
    </p>
    

  </div>
  <script>
    
    mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
      margin: 24,
      background: 'rgba(0,0,0,0.5)',
      scrollOffset: 0,
    })
    
  </script>
  
  
  <script type="text/javascript" src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js" integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]"
  data-url="https://your_domain.com/"
  style="z-index:500"
>
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"
  >
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          

  <span class="relative block icon">
    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>

  </span>


        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="搜索"
          tabindex="0"
        />
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="关闭 (Esc)"
      >
        

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>

  </span>


      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

  </div>
</body>

</html>
